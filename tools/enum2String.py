#!/usr/bin/python
# -*- coding: utf-8 -*-

import sys
import os.path
import subprocess
import time
import re
import shlex
import datetime
from optparse import OptionParser
from pyparsing import *

#___________________________________________________________________
def syntax(error):
  if error != None:
    print "\n\033[91m%s !!!\033[0m\n"%(error)

  print "\nUsage: enum2String.py -n <enum> -f <file> [ -c <#char> ] [ extra options ]\n"
  print "  -n <enum>    provides the name of the enumeration"
  print "  -f <file>    provides the file name containing the enumeration definition"
  print "  -c <#char>   enables to truncate the <#char> first characters from the enumeration definitions"
  print "\nExtra options:"
  print "  -u           May be used to avoid transformation of underscores to spaces"
  print "  -l           For lower case display"
  print "  -U           For upper case display"
  print "  -r           When set, the reverse string to enum function is also generated"
  sys.exit(1)	     

#___________________________________________________________________
def parse_file(enum_name, fname):

  # Read source file name 
  inside = False
  enum=""
  upper = enum_name.upper()
  lower = enum_name.lower()

  with open (fname, "r") as myfile:
    
    for line in myfile:
      
      if "typedef enum" in line and ( enum_name in line or upper in line or lower in line) :
        enum   = ""
        inside = True
        continue
        
      if inside:
        if ( enum_name in line or upper in line or lower in line) and "}" in line : 
          return enum
        line = line.replace("\n","") 
        line = line.replace("{","") 
        line = line.replace("}","")
        line = line.replace(" ","")
        line = line.split(',')[0] +','
        line = line.split("//")[0]
        enum = enum + line
        if line == "": continue
        
  return None

#___________________________________________________________________
def generate_file(enum_name):

  FNAME = "%s2String.h"%(enum_name)
  TMP   = "/tmp/%s"%(FNAME)

  # Save stdout and replace it with the output file  
  save_stdout = sys.stdout
  sys.stdout = open(TMP,"w")

  print "#ifndef __%s2String_h__"%(enum_name)
  print "#define __%s2String_h__"%(enum_name) 

  print "#ifdef __cplusplus"
  print "extern \"C\" {"
  print "#endif /*__cplusplus*/"

  print "#include <strings.h>"

  print "\n/*___________________________________________________________________"
  print " "
  print "   Generated by enum2String.py "
  print "   Date : %s"%(datetime.datetime.now().strftime("%A %Y %B %d, %H:%M:%S"))
  print "   Command line : "
  # Print command
  cmd=""
  for param in sys.argv:
    cmd = cmd + " " + param
  print cmd
  print "\n  ____________________________________________________________________"
  print "*/"


  print "\n/*_________________________________________________________________"
  print " * Builds a string from an integer value supposed to be within"
  print " * the enumerated list %s"%(enum_name) 
  print " *"  
  print " * @param x : value from %s to translate into a string"%(enum_name) 
  print " *"
  print " * The input value is translated into a string deduced from the enum"
  print " * definition. When the input value do not fit any of the predefined"
  print " * values, \"??\" is returned" 
  print " *"
  print " * @return A char pointer to the constant string or \"??\""
  print " *_________________________________________________________________*/ "   
  print "static inline char * %s2String (const %s x) {"%(enum_name,enum_name) 
  print "  switch(x) {"

  for value in enum.split(','):

    val_name = value.split("=")[0]
    val_name = val_name.replace(" ","")

    if val_name == "": continue

    val_display = val_name[cut:]   
    if options.underscore == False: val_display = val_display.replace("_", " ")
    if options.lower == True:  val_display = val_display.lower()   
    if options.upper == True:  val_display = val_display.upper()       
    print "    case %-40s: return(\"%s\");"%(val_name,val_display)  

  print "    /* Unexpected value */";
  print "    default: return \"??\";"
  print "  }";
  print "}";


  # Generate reverse stgring to enum function when requested
  if options.reverse == True:
    print "/*_________________________________________________________________"
    print " * Translate a string supposed to be within the enumerated list"
    print " * %s to its integer value."%(enum_name) 
    print " *"  
    print " * @param s : the string to translate into an integer" 
    print " *"
    print " * The input string is translated into its corresponding integer value."
    print " * When the input value do not fit any expected string -1 is returned."
    print " *"
    print " * @return The integer value or -1"
    print " *_________________________________________________________________*/ "   
    print "static inline int string2%s (const char * s) {"%(enum_name) 

    for value in enum.split(','):

      val_name = value.split("=")[0]
      val_name = val_name.replace(" ","")

      if val_name == "": continue

      val_display = val_name[cut:]   
      if options.underscore == False: val_display = val_display.replace("_", " ")
      print "  if (strcasecmp(s,\"%s\")==0)  \treturn %s;"%(val_display,val_name)  
    print "  /* Unexpected value */";
    print "  return -1;"
    print "}";


  print ""
  print "#ifdef	__cplusplus";
  print "}";
  print "#endif";
  print "#endif\n";

  # Restore stdout
  sys.stdout.close()
  sys.stdout = save_stdout

  if not os.path.exists(FNAME):
    os.rename(TMP,FNAME)
    print "\033[96mCreated %s/%s2String.h\033[0m"%(os.getcwd(),enum_name)
  else :
    with open(TMP) as tmp:
      with open(FNAME) as f:
          for idx, (lineA, lineB) in enumerate(zip(tmp, f)):
            if lineA != lineB:
              if "Date :" in lineA and "Date :" in lineB: 
                continue
              # File are different
              os.rename(TMP,FNAME)
              print "\033[96mUpdated %s/%s2String.h\033[0m"%(os.getcwd(),enum_name)    
              break          
    if os.path.exists(TMP):       
      print "\033[93mUnchanged %s/%s2String.h\033[0m"%(os.getcwd(),enum_name)   
      os.remove(TMP) 


#___________________________________________________________________
def re_generate_directory(zed):

  #print "re_generate_directory %s"%(d)

  os.chdir(zed)  
  #
  # Get list of files and subdirectories
  #
  for f in os.listdir(zed):
  
    # Check local 2String.h files
    if os.path.isfile(f):
       if not "2String.h" in f: continue
       # Find out the command line to replay
       command = None
       next    = False
       with open(f) as zef:
         for ln, line in enumerate(zef):
           if "Command line :" in line:
             next = True   
             continue
           if next == True:
             command = line
             break
       if command == None:
         print "\033[91mFile %s/%s do not contain command line !!!\033[0m"%(dirname,f)
         continue  
       os.system(command)
       continue   
       
    # Process sub directories
    if os.path.isdir(f):
      re_generate_directory("%s/%s"%(zed,f))
      os.chdir(zed)     
               
 
###############################################
parser = OptionParser()
parser.add_option("-n","--name", action="store",type="string", dest="name", help="Enum name.")
parser.add_option("-f","--file", action="store",type="string", dest="fname", help="File name.")
parser.add_option("-c","--cut", action="store",type="string", dest="cut", help="number of char to remove at the beginning")
parser.add_option("-u","--underscore", action="store_true",default=False, dest="underscore", help="To keep underscores")
parser.add_option("-l","--lower", action="store_true",default=False, dest="lower", help="To use lower case display")
parser.add_option("-U","--upper", action="store_true",default=False, dest="upper", help="To use upper case display")
parser.add_option("-r","--reverse", action="store_true",default=False, dest="reverse", help="Generate string to enum function too")
parser.add_option("-R","--regenerate", action="store_true",default=False, dest="regenerate", help="Generate every file in this directory.")

(options, args) = parser.parse_args()

# Regenerate command 
# Recursively regenerate all 2String.h files
if options.regenerate == True:
  re_generate_directory(os.getcwd())
  sys.exit(0)
      
# Check enum name is given
if options.name == None: 
  syntax("Missing enum name")   
enum_name = options.name


if options.lower == True and options.upper == True:
  syntax ("-l and -U are incompatible options");

# Check number of char to cut at the beginning
if options.cut == None:
  cut = int(0)
else:
  try:
    cut = int(options.cut)  
  except:
    syntax("Bad cut value %s"%(options.cut))
     
# Check source file name is given
if options.fname == None:
  syntax("Missing source file name")

# Check source file name exists  
if not os.path.exists(options.fname):
  syntax("%s file does not exist"%(options.fname))
  
# Read source file name 
enum = parse_file(enum_name,options.fname)
if enum == None:
  syntax("No such enum %s in file %s"%(enum_name,options.fname))

generate_file(enum_name)
    
